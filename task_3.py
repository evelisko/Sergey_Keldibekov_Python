# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка.
# В его конструкторе инициализировать параметр, соответствующий количеству клеток (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (add()), вычитание (sub()),
# умножение (mul()), деление (truediv()).Данные методы должны применяться только к клеткам и выполнять увеличение,
# уменьшение, умножение и обычное (не целочисленное) деление клеток, соответственно.
# В методе деления должно осуществляться округление значения до целого числа.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток
# больше нуля, иначе выводить соответствующее сообщение. Умножение. Создается общая клетка из двух.
# Число ячеек общей клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление
# количества ячеек этих двух клеток. В классе необходимо реализовать метод make_order(), принимающий экземпляр
# класса и количество ячеек в ряду. Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида **\n\n***..., где количество ячеек между \n равно переданному аргументу.
# Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order()
# вернет строку: **\n\n. Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5.
# Тогда метод make_order() вернет строку: **\n\n***.
# Подсказка: подробный список операторов для перегрузки доступен по ссылке.



class Worker(object):

    def __init__(self, name, surname, position):
        self._name = name
        self._surname = surname
        self._position = position
        self._income = {"wage": None,
                        "bonus": None}  # по идее, этот атрибут можно здесь не определять а задать в дочернем классе.

    def __str__(self):
        return f'{self._name} {self._surname}'

    def set_income(self, **income):
        try:  # if float_convert(income['wage']) != -1 and float_convert(income['bonus']) != -1:
            self._income = income
            if self._income['wage'] < 12000:
                print(f'зарплата работника ({self._name} {self._surname}) не может быть ниже прожиточного минимума!!!')
                # self._income['wage'] = 12000   # установить зарплату равную прожиточнуму минимуму
        except:
            print('не верный формат для данных')


class Position(Worker):

    def __init__(self, name, surname, position, wage=12000, bonus=0):
        super().__init__(name, surname, position)
        self.set_income(wage=wage, bonus=bonus)

    def get_full_name(self):
        return f'{self._name} {self._surname} - {self._position}'

    def get_total_income(self):
        return self._income['wage'] + self._income['bonus']


worker_1 = Position('Иван', 'Иванов', position='Водитель', wage=12000, bonus=1500)
print(worker_1.get_full_name())
print(f'Зарплата: {worker_1.get_total_income()}')

worker_2 = Position('Юрий', 'Иванов', position='Водитель')
worker_2.set_income(wage=10000, bonus=1600)
print(worker_2.get_full_name())
print(f'Зарплата: {worker_2.get_total_income()}')
